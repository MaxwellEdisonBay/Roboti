#include "global.nxc";
#include "sensor.nxc";

#include "gui.nxc";


void init ()
{
  SetSensorTouch(S2);
  SetSensorLight(S1);
  SetSensorUltrasonic(S4);
}


void calibrate()
{
  if(SENSOR_btnPressed && min == 0)
  {
    min = SENSOR_light();
    GUI_setMsg("Calibrate light.");
  }
  else if(SENSOR_btnPressed && min != 0 && max == 0)
  {
    max = SENSOR_light();
    desired = (min + max) / 2.0;
    GUI_setMsg("Calibrated!");

  }
  else if(SENSOR_btnPressed && desired != 0)
  {
    calibrated = 1;
    /* OnFwd(OUT_B, 100);

    // Left motor 0 ... 100 (Turn right)
    OnFwd(OUT_C, 100);
    Wait(500); */

  }
}

int MIN(int a, int b)
{
  if(a > b)
    return b;
  return a;
}

int MAX(int a, int b)
{
  if(a < b)
    return b;
  return a;
}

int LIMIT(int a, int b, int c)
{
  return MIN(MAX(a, b), c);
}


void followLine_Copy_Paste(){
  error = (SENSOR_lightValue - desired);

  proportional = error;
  int minPwd = 0;

  integral += error * passedTicks/1000;
  derivative = (error - previous_error) * passedTicks/1000;

  //const int add = 1;
  minPwd = 60;

  const float Pc = 2.0; // period

  const float Kc = 175;

  float kp = 0.81 * Kc;
  float ki = 0;//2.0 * kp / 1000 / Pc;
  float kd = 5.0 * kp * Pc / (8 / 1000);


  const float limit = 0.1;
  if(integral > limit)
    integral = limit;
  else if(integral < -limit)
    integral = -limit;

  motorLeft = minPwd - kp*proportional - ki*integral - kd*derivative;
  motorRight = minPwd + kp*proportional + ki*integral + kd*derivative;

  previous_error = error;
  // Right motor 0 ... 100 (Turn left)
  OnFwd(OUT_B, LIMIT(motorRight, 0, 100));

  // Left motor 0 ... 100 (Turn right)
  OnFwd(OUT_C, LIMIT(motorLeft, 0, 100));
  Wait(std_time);
}


void run ()
{
  unsigned int www = 0;

  GUI_setMsg("Calibrate dark.");
  //calibrated = 1;
  // ====================== TEST
  /*calibrated = 1;
  desired = 0.39;
  while(!SENSOR_btnPressed) {
    SENSOR_btn();
    Wait(1);
  }*/
  // ====================== TEST
  lastTick = CurrentTick();
  SENSOR_ultra();

  while (true) {

    SENSOR_sense();

    /*www += 1;
    if(www > 150) {
      SENSOR_ultra();
      www = 0;
    }*/

    if(calibrated) {
      /* followLine(); */
      followLine_Copy_Paste();
      if(SENSOR_btnPressed)
      {
        Off(OUT_BC);
        Wait(4000);
        break;
      }
    } else {
      calibrate();
    }

    if(SENSOR_btnPressed) {
      GUI_showPopup("Pressed!");
      Wait(600);
    }

    GUI_showGUI();

    SENSOR_btnPressed = 0;

    passedTicks = CurrentTick() - lastTick;
    lastTick = CurrentTick();
    /* dt = passedTicks / 1000.0; */
    /* if (passedTicks > std_time){
      float multiplierConst = 0.3;
      if (counter == 0){
        last_error = error;
        counter ++;
      }
      der_coeff = 1 + abs((last_error - error))/passedTicks*multiplierConst;

      lastTick = CurrentTick();
      last_error = error;
    } */
  }
}

task main () {
    init();
    TextOut(10, 10, "ATOM TEST");
    run();
}
